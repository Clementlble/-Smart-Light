<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-gradient: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            --bg-dark: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --card-border: rgba(255, 255, 255, 0.1);
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(168, 85, 247, 0.15) 0px, transparent 50%);
            min-height: 100vh;
            color: var(--text-main);
            padding: 16px;
            line-height: 1.5;
        }

        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .dashboard.hidden { display: none; }

        .card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            padding: 24px;
            border: 1px solid var(--card-border);
            margin-bottom: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding: 8px;
        }

        .header-info h1 {
            font-size: 24px;
            font-weight: 700;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--card-border);
            border-radius: 14px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn:hover { background: rgba(255, 255, 255, 0.1); }

        .btn-primary {
            background: var(--primary-gradient);
            border: none;
        }

        /* --- WEATHER --- */
        .weather-grid {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .temp-display {
            font-size: 48px;
            font-weight: 700;
            display: flex;
        }

        .temp-display span {
            font-size: 24px;
            color: var(--primary);
            margin-top: 8px;
        }

        /* --- SCENES --- */
        .scenes-row {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
            margin-bottom: 24px;
            scrollbar-width: none;
        }
        .scenes-row::-webkit-scrollbar { display: none; }

        .scene-btn {
            flex: 0 0 auto;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--card-border);
            border-radius: 100px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .scene-btn:hover { background: rgba(255, 255, 255, 0.12); }
        .scene-btn:active { transform: scale(0.95); background: var(--primary); }

        /* --- LIGHTS --- */
        .lights-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .light-item {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            padding: 24px;
            border: 1px solid var(--card-border);
            transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .light-item.on {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(99, 102, 241, 0.3);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.1);
        }

        .light-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .toggle-pill {
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            transition: 0.3s;
        }

        .toggle-pill::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: 0.3s cubic-bezier(0.18, 0.89, 0.35, 1.15);
        }

        .light-item.on .toggle-pill { background: var(--success); }
        .light-item.on .toggle-pill::after { left: 27px; }

        /* --- SLIDERS --- */
        .control-group {
            margin-top: 16px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .hue-slider {
            background: linear-gradient(to right, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%) !important;
            margin-top: 12px;
        }

        .login-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
    </style>
</head>
<body>

    <div id="loginOverlay" class="login-overlay">
        <div class="card" style="width: 100%; max-width: 400px; text-align: center;">
            <div style="margin-bottom: 24px; color: var(--primary);"><i data-lucide="shield-check" style="width: 48px; height: 48px;"></i></div>
            <h2 style="margin-bottom: 8px;">Authentification</h2>
            <p style="color: var(--text-muted); margin-bottom: 24px;">Connectez votre instance Home Assistant</p>
            <input type="password" id="haToken" placeholder="Token d'accès longue durée..." style="width: 100%; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--card-border); padding: 16px; border-radius: 16px; color: white; margin-bottom: 16px; font-size: 14px;">
            <button class="btn btn-primary" style="width: 100%; justify-content: center; padding: 16px;" onclick="connectHA()">
                Déverrouiller le Dashboard
            </button>
        </div>
    </div>

    <div id="mainDashboard" class="dashboard hidden">
        <header class="header">
            <div class="header-info">
                <h1 id="welcomeText">Dashboard Intelligent</h1>
                <p id="liveClock" style="color: var(--text-muted); font-size: 14px; margin-top: 4px;">--:--:--</p>
            </div>
            <div style="display: flex; gap: 8px;">
                <button class="btn" onclick="refreshData()"><i data-lucide="rotate-cw" style="width: 18px;"></i></button>
                <button class="btn" onclick="logout()"><i data-lucide="log-out" style="width: 18px;"></i></button>
            </div>
        </header>

        <!-- Météo Dynamique -->
        <section class="card weather-grid">
            <div>
                <div class="temp-display" id="currentTemp">--<span>°C</span></div>
                <p id="weatherDesc" style="font-weight: 600; font-size: 18px; margin: 4px 0;">Récupération météo...</p>
                <div style="display: flex; align-items: center; gap: 6px; color: var(--text-muted); font-size: 13px;">
                    <i data-lucide="map-pin" style="width: 14px;"></i>
                    <span id="cityName">Recherche de la position...</span>
                </div>
            </div>
            <div id="weatherIconContainer" style="font-size: 48px; color: var(--warning);">
                <i data-lucide="cloud-sun" style="width: 56px; height: 56px;"></i>
            </div>
        </section>

        <h3 style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 700;">Scènes de la maison</h3>
        <div class="scenes-row" id="scenesContainer">
            <button class="scene-btn" onclick="activateScene('scene.cinema')"><i data-lucide="tv"></i> Mode Cinéma</button>
            <button class="scene-btn" onclick="activateScene('scene.lecture')"><i data-lucide="book-open"></i> Lecture</button>
            <button class="scene-btn" onclick="activateScene('scene.soiree')"><i data-lucide="party-popper"></i> Soirée</button>
            <button class="scene-btn" onclick="activateScene('scene.travail')"><i data-lucide="briefcase"></i> Travail</button>
            <button class="scene-btn" onclick="activateScene('scene.nuit')"><i data-lucide="moon"></i> Bonne Nuit</button>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 20px; padding: 0 4px;">
            <h2 style="font-size: 20px;">Gestion des Lumières</h2>
            <div id="lightsStatus" style="color: var(--primary); font-weight: 600; font-size: 14px; background: rgba(99, 102, 241, 0.1); padding: 4px 12px; border-radius: 20px;">Chargement...</div>
        </div>
        
        <section class="lights-container" id="lightsContainer"></section>
    </div>

    <script>
        const haUrl = 'http://192.168.0.12:8123';
        let haToken = localStorage.getItem('haToken') || '';
        let lights = [];
        let isHandlingAction = false;
        let userInteracting = {};

        const weatherMap = {
            0: { desc: 'Ciel dégagé', icon: 'sun' },
            1: { desc: 'Dégagé', icon: 'sun' },
            2: { desc: 'Partiellement nuageux', icon: 'cloud-sun' },
            3: { desc: 'Couvert', icon: 'cloud' },
            45: { desc: 'Brouillard', icon: 'cloud-fog' },
            61: { desc: 'Pluie faible', icon: 'cloud-rain' },
            95: { desc: 'Orage', icon: 'cloud-lightning' }
        };

        function updateClock() {
            const now = new Date();
            document.getElementById('liveClock').textContent = now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' }) + ' • ' + now.toLocaleTimeString('fr-FR');
        }
        setInterval(updateClock, 1000);
        updateClock();

        async function connectHA() {
            const tokenInput = document.getElementById('haToken').value.trim();
            if (!tokenInput) return;
            haToken = tokenInput;
            
            if (await refreshData()) {
                localStorage.setItem('haToken', haToken);
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('mainDashboard').classList.remove('hidden');
                lucide.createIcons();
                // Polling optimisé toutes les 1.5s pour synchro temps réel
                setInterval(refreshData, 1500);
            } else {
                alert("Impossible de se connecter. Vérifiez votre token.");
            }
        }

        async function refreshData() {
            try {
                const response = await fetch(`${haUrl}/api/states`, {
                    headers: { 'Authorization': `Bearer ${haToken}` }
                });
                if (!response.ok) return false;
                const states = await response.json();
                const newLights = states.filter(e => e.entity_id.startsWith('light.'));
                
                // Détection intelligente des changements
                const hasChanges = detectChanges(lights, newLights);
                
                if (hasChanges || lights.length !== newLights.length) {
                    const oldLights = [...lights];
                    lights = newLights;
                    
                    if (!isHandlingAction) {
                        renderLights();
                    } else {
                        // Mise à jour silencieuse pendant action utilisateur
                        updateLightStates(oldLights, newLights);
                    }
                }
                
                updateWeather();
                updateUI();
                return true;
            } catch (e) { 
                console.error("Erreur refresh:", e);
                return false; 
            }
        }

        function detectChanges(oldLights, newLights) {
            if (oldLights.length !== newLights.length) return true;
            
            return newLights.some((newLight, i) => {
                const oldLight = oldLights.find(l => l.entity_id === newLight.entity_id);
                if (!oldLight) return true;
                
                // Comparer état, luminosité et couleur
                return newLight.state !== oldLight.state ||
                       newLight.attributes.brightness !== oldLight.attributes.brightness ||
                       JSON.stringify(newLight.attributes.hs_color) !== JSON.stringify(oldLight.attributes.hs_color);
            });
        }

        function updateLightStates(oldLights, newLights) {
            newLights.forEach(newLight => {
                // Ne pas mettre à jour si l'utilisateur interagit avec ce contrôle
                if (userInteracting[newLight.entity_id]) return;
                
                const card = document.getElementById(`card-${newLight.entity_id}`);
                const brightnessLabel = document.getElementById(`brightness-${newLight.entity_id}`);
                const brightnessSlider = document.getElementById(`slider-brightness-${newLight.entity_id}`);
                const hueSlider = document.getElementById(`slider-hue-${newLight.entity_id}`);
                
                if (!card) return;
                
                const isOn = newLight.state === 'on';
                const brightness = newLight.attributes.brightness ? Math.round((newLight.attributes.brightness / 255) * 100) : 0;
                const hue = newLight.attributes.hs_color ? Math.round(newLight.attributes.hs_color[0]) : 0;
                
                // Mise à jour visuelle
                if (isOn) card.classList.add('on');
                else card.classList.remove('on');
                
                // Mise à jour des contrôles
                if (brightnessLabel) brightnessLabel.textContent = `${brightness}%`;
                if (brightnessSlider) brightnessSlider.value = brightness;
                if (hueSlider) hueSlider.value = hue;
            });
        }

        function updateUI() {
            const onCount = lights.filter(l => l.state === 'on').length;
            document.getElementById('lightsStatus').textContent = onCount > 0 ? `${onCount} active(s)` : 'Toutes éteintes';
        }

        function renderLights() {
            const container = document.getElementById('lightsContainer');
            container.innerHTML = lights.map(light => {
                const isOn = light.state === 'on';
                const brightness = light.attributes.brightness ? Math.round((light.attributes.brightness / 255) * 100) : 0;
                const supportsColor = light.attributes.supported_color_modes?.some(m => ['hs', 'rgb', 'xy'].includes(m));
                const currentHue = light.attributes.hs_color ? Math.round(light.attributes.hs_color[0]) : 0;

                return `
                    <div class="light-item ${isOn ? 'on' : ''}" id="card-${light.entity_id}">
                        <div class="light-top">
                            <div style="font-weight: 700; font-size: 16px;">${light.attributes.friendly_name}</div>
                            <div class="toggle-pill" onclick="handleToggle('${light.entity_id}')"></div>
                        </div>
                        <div class="control-group">
                            <div class="slider-label"><span>Intensité</span><span id="brightness-${light.entity_id}">${brightness}%</span></div>
                            <input type="range" min="0" max="100" value="${brightness}" id="slider-brightness-${light.entity_id}"
                                onmousedown="startInteraction('${light.entity_id}')"
                                ontouchstart="startInteraction('${light.entity_id}')"
                                oninput="syncLocalBrightness('${light.entity_id}', this.value)"
                                onchange="commitBrightness('${light.entity_id}', this.value)"
                                onmouseup="endInteraction('${light.entity_id}')"
                                ontouchend="endInteraction('${light.entity_id}')">
                        </div>
                        ${supportsColor ? `
                        <div class="control-group">
                            <div class="slider-label"><span>Ambiance couleur</span></div>
                            <input type="range" class="hue-slider" min="0" max="360" value="${currentHue}" id="slider-hue-${light.entity_id}"
                                onmousedown="startInteraction('${light.entity_id}')"
                                ontouchstart="startInteraction('${light.entity_id}')"
                                oninput="syncLocalHue('${light.entity_id}', this.value)"
                                onchange="commitHue('${light.entity_id}', this.value)"
                                onmouseup="endInteraction('${light.entity_id}')"
                                ontouchend="endInteraction('${light.entity_id}')">
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            lucide.createIcons();
        }

        function startInteraction(entityId) {
            userInteracting[entityId] = true;
        }

        function endInteraction(entityId) {
            setTimeout(() => {
                userInteracting[entityId] = false;
            }, 50);
        }

        // --- GESTION INSTANTANÉE (ZÉRO DÉLAI) ---
        function syncLocalBrightness(entityId, value) {
            const card = document.getElementById(`card-${entityId}`);
            const light = lights.find(l => l.entity_id === entityId);
            const label = document.getElementById(`brightness-${entityId}`);
            
            if (!card || !light || !label) return;

            label.textContent = `${value}%`;
            
            if (value > 0) {
                card.classList.add('on');
                light.state = 'on';
                light.attributes.brightness = Math.round((value / 100) * 255);
            } else {
                card.classList.remove('on');
                light.state = 'off';
                light.attributes.brightness = 0;
            }
            updateUI();
        }

        function syncLocalHue(entityId, value) {
            const light = lights.find(l => l.entity_id === entityId);
            if (light && light.attributes) {
                light.attributes.hs_color = [parseInt(value), 100];
            }
        }

        async function commitBrightness(entityId, value) {
            // Pas de blocage, envoi immédiat en arrière-plan
            if (value > 0) {
                callService('light', 'turn_on', { entity_id: entityId, brightness_pct: parseInt(value) });
            } else {
                callService('light', 'turn_off', { entity_id: entityId });
            }
        }

        async function commitHue(entityId, value) {
            // Pas de blocage, envoi immédiat en arrière-plan
            const rgb = hslToRgb(parseInt(value), 100, 50);
            callService('light', 'turn_on', { entity_id: entityId, rgb_color: rgb });
        }

        async function handleToggle(entityId) {
            const light = lights.find(l => l.entity_id === entityId);
            if (!light) return;
            
            const newState = light.state === 'on' ? 'off' : 'on';
            
            // UI Immédiate
            const card = document.getElementById(`card-${entityId}`);
            if (card) {
                if (newState === 'on') card.classList.add('on');
                else card.classList.remove('on');
            }
            light.state = newState;
            updateUI();
            
            // Envoi commande en arrière-plan sans bloquer
            callService('light', newState === 'on' ? 'turn_on' : 'turn_off', { entity_id: entityId });
        }

        async function activateScene(sceneId) {
            isHandlingAction = true;
            try {
                await callService('scene', 'turn_on', { entity_id: sceneId });
            } finally {
                // Rafraîchissement après délai pour laisser le temps aux entités de changer
                setTimeout(() => { 
                    isHandlingAction = false; 
                    refreshData();
                }, 600);
            }
        }

        async function callService(domain, service, data) {
            try {
                const response = await fetch(`${haUrl}/api/services/${domain}/${service}`, {
                    method: 'POST',
                    headers: { 
                        'Authorization': `Bearer ${haToken}`, 
                        'Content-Type': 'application/json' 
                    },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) {
                    console.error(`Erreur service ${domain}.${service}:`, response.status);
                }
                
                return response.ok;
            } catch (e) { 
                console.error(`Erreur Service HA ${domain}.${service}:`, e);
                return false;
            }
        }

        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            return [
                Math.round(hue2rgb(p, q, h + 1/3) * 255), 
                Math.round(hue2rgb(p, q, h) * 255), 
                Math.round(hue2rgb(p, q, h - 1/3) * 255)
            ];
        }

        async function updateWeather() {
            navigator.geolocation.getCurrentPosition(async (pos) => {
                const { latitude, longitude } = pos.coords;
                
                try {
                    // Météo
                    const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,weather_code&timezone=auto`);
                    const weatherData = await weatherRes.json();
                    
                    const temp = Math.round(weatherData.current.temperature_2m);
                    const info = weatherMap[weatherData.current.weather_code] || { desc: 'Partiellement nuageux', icon: 'cloud-sun' };

                    document.getElementById('currentTemp').innerHTML = `${temp}<span>°C</span>`;
                    document.getElementById('weatherDesc').textContent = info.desc;
                    document.getElementById('weatherIconContainer').innerHTML = `<i data-lucide="${info.icon}" style="width: 56px; height: 56px;"></i>`;
                    
                    // Géocodage Ville (une seule fois)
                    const cityEl = document.getElementById('cityName');
                    if (cityEl && !cityEl.hasAttribute('data-done')) {
                        const geoRes = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
                        const geoData = await geoRes.json();
                        const city = geoData.address.city || geoData.address.town || geoData.address.village || "Ma Position";
                        cityEl.textContent = city;
                        cityEl.setAttribute('data-done', 'true');
                    }
                    lucide.createIcons();
                } catch(e) {
                    console.error("Erreur météo:", e);
                }
            }, (err) => {
                console.warn("Géolocalisation refusée:", err);
                document.getElementById('cityName').textContent = "Position non disponible";
            });
        }

        function logout() {
            localStorage.removeItem('haToken');
            location.reload();
        }

        window.addEventListener('load', () => { 
            if (haToken) connectHA(); 
            lucide.createIcons();
        });
    </script>
</body>
</html>
